"""Functions to compute graph-cut and MaxCut of a graph: `compute_cut_score`, `brute_force_maxcut`.
Dataclass to store brute-force MaxCut results: `BruteForceResult`.
"""

from dataclasses import dataclass
from typing import Set, List, Tuple, Optional

import networkx as nx

@dataclass
class BruteForceResult:
    """
    A container for data generated by the `brute_force_maxcut` function.

    Attributes:
        partitions_scores (List[Tuple[str, int]]): (partition, score) for all possible partitions.
        best_score (int): the best MaxCut score possible for the analyzed graph.
        optimal_partitions (Set[str]): all partitions that yield the best score.
    """

    partitions_scores: List[Tuple[str, int]]
    best_score: int
    optimal_partitions: Set[str]


def compute_cut_score(graph: nx.Graph, bitstring: str) -> int:
    """
    For a given graph and a given partition (defined by a bitstring), computes 
    the number of edges (= "cut score") that connect the two complimentary subsets
    of vertices that the bitstring defines (by the partition to ones and zeros).

    Args:
        graph (nx.Graph): the graph to compute the cut score for.
        bitstring (str): a bitstring that defines a certain partition of the graph
        into 2 complimentary subsets of vertices.

    Returns:
        (int): The cut score of `bitstring` w.r.t to `graph` = the number of edges that connect
        the 2 complimentary subsets of the graph's nodes.
    """

    # Reversing for little-endianess
    bitstring = bitstring[::-1]

    score = 0
    for edge in graph.edges:

        # Adds 1 if and only if the 2 nodes are of the same subset
        score += (int(bitstring[int(edge[0])]) ^ int(bitstring[int(edge[1])]))

    return score


def brute_force_maxcut(graph: nx.Graph, num_blue_nodes: Optional[int] = None) -> BruteForceResult:
    """
    Checks every possible partition of the graph's vertices by classical brute-force.

    Args:
        graph (nx.Graph): the graph so solve the MaxCut problem for.

    Returns:
        (BruteForceResult): A packed complete MaxCut anaylsis for the given graph.

    """

    # Associating each possible parittion with its cut-score
    scores_dict = {}
    num_nodes = graph.number_of_nodes()
    for num in range(2 ** num_nodes):
        bitstring = bin(num)[2:].zfill(num_nodes)

        if num_blue_nodes is not None and bitstring.count("1") != num_blue_nodes:
            continue

        scores_dict[bitstring] = compute_cut_score(graph, bitstring)

    partitions_scores = sorted(scores_dict.items(), key=lambda item: item[1], reverse=True)
    best_score = partitions_scores[0][1]

    optimal_partitions = set()
    for partition in partitions_scores:
        if partition[1] < best_score:
            break
        optimal_partitions.add(partition[0])

    return BruteForceResult(partitions_scores, best_score, optimal_partitions)